# Move mutator tool design

## Overview

The Move mutator tool is a tool that mutates Move source code. It is used to help testing the robustness of Move analyzers and verifiers by generating different code versions (mutants).

## Prototype
This chapter will be deleted upon finishing the implementation of the Move mutator tool.

The Prototype implements only: binary operator replacement (arithmetic, bitwise and shifts) and unary operator replacement. Command line options are mainly handling source file path (single file or package).

Mutants are currently stored in the `mutants_output` directory and there is no way to change it. Mutants are just saved in a flat structure (no subdirectories). Each mutant filename consists of original source filename with the next index appended. 

Report is generated on screen and is listing all generated mutants (which mutation operator was used, location in the original source file, mutant output). It's not possible to generate report in a file.

Not supported: configuration file, generating reports, nice output, mutant files output structure, other mutation operators than binary and unary operator replacement.

### What's missing in the Move ecosystem



##  Architecture

The Move mutator tool is composed of the modules, that are described below. Each module is responsible for a different part of the application to allow for easy extension and modification. Modules are grouped into logical layers which provides separation and isolation of the application parts.

The Move mutator tool is the heart of the specification verification process, as depending on its quality, the verification process will be more or less efficient. The Move mutator tool is designed to be easily extensible, so it's possible to add new mutation operators, new mutation categories and so on.

Mutation process is separated from the other parts of the verification process. It makes it possible to use mutator output (mutants) to verify specification's quality using Move Prover, but also to check completness and quality of testsuites. Users can also use mutants in their own applications and scripts.

### Presentation layer

The presentation layer is responsible for interaction with the user. To keep the application usage consistent, the presentation layer will use the same API calls used by external systems to execute commands received from a user. 

In this project the persentation layer execution modules (displaying and fetching data from/to user) are moved to the `aptos` and `move` command line interface. 

Mutator itself provides a CLI module, which is integrated into the existing Aptos repository - provides options that mutator tool can use.

There are two types of output that the Move mutator tool generates:
- the actual mutants (source code files)
- the report (JSON and text file)

The actual mutants are stored in the output (default: `mutants_output`) directory. Each mutant is stored in a separate directory. The directory name is composed of the mutation operator name and the mutation operator index. For example, the `binary_operator_replacement_0` directory contains mutants generated by the `binary_operator_replacement` mutation operator. The `0` index is used to distinguish between different mutants generated by the same mutation operator.

### Service layer

Contains an API module which is exposing function calls to other modules (internal or external). 



### Main logic layer

This layer is responsible for the main logic of the application. The main application layer with crucial components used to generate mutants:
Mutation checker - managing component responsible for running generation process, checking correctness and generating prover calls if needed.
Report generator - module responsible for creating summaries over generated mutants.
Checker - component checking if mutation should be applied (filtering) and running prover internally.
Mutant generator - mutant generator component, incorporating AST traversal module, which goes through the syntax tree and mutation operator component, which handles different transformations. In fact, this will be the most prominent component and a subject to the most significant future changes.

The functions contained in the `mutate.rs` are responsible for traversing the Abstract Syntax Tree (AST) of the Move source code and searching for places where potential mutation operators can be applied. It has been AST from the `parser` Move compiler module used, but it's not a big change to traverse other trees. `parser` tree has been used because it's the closest module to the original source file and represents exact structure of the source file. It makes it much easier to replace expressions with the mutated ones.
The idea behind that searching is as follows:
- The `mutate` function is the entry point. It takes the AST of a Move program as input and returns a list of mutants (not yet generated). It does this by iterating over the source definitions in the AST and calling the appropriate function to traverse each definition based on its type (Address, Module, or Script).  
- The `traverse_module` function is called for each module in the AST. It iterates over the members of the module and calls the appropriate function to traverse each member based on its type (like Function or Constant).
- `traverse_function` is called for each function found. It looks for a function body, and calls the `traverse_sequence` to traverse the sequence of expressions.  
- `traverse_sequence` is executed for each sequence. It iterates over the sequence items and calls the `traverse_sequence_item` for them.  
- `traverse_sequence_item` checks the type of the sequence item (`Bind` or `Seq`) and calls the `parse_expression` function to parse the expression associated with the sequence item.
- the main parsing function is the `parse_expression`. It checks the type of the expression and marks that place as the appropriate for the mutation operator to be applied (e.g., binary or unary expressions). Sub-expressions are parsed recursively.

When new place for mutation is found any of the above functions can create a new mutant. The mutation operator is passed as an argument, which contain appropriate AST node. As each node contains its own location (`Spanned` structure with `Loc`) it's possible to just pass the node without any  
This process continues recursively until all nodes in the AST have been visited and all possible mutants have been generated. The list of mutants is then returned by the mutate function.

### Data layer

This layer is responsible for handling data sources - reading Move projects (source code) and configuration file. It also provides data to the other layers.

Configuration file is a JSON file that contains configuration of the Move mutator tool. It contains information about the project to mutate, mutation operators to use, mutation categories to use, and so on.

Sample configuration file:
```json
{
    "project": {
        "path": "path/to/project",
        "files": [
            "path/to/file1",
            "path/to/file2"
        ]
    },
    "mutation": {
        "operators": [
            "binary_operator_replacement",
            "unary_operator_replacement"
        ],
        "categories": [
            "arithmetic",
            "bitwise",
            "shifts"
        ]
    }
}
```

### Cross layer

The layer is used to provide a common function set to other layers. None of their functions is exposed externally. Its crucial components are:
Logging module - gathers logs from other internal components and allows to save it for further analysis.
IO support - various input/output functions (formatters) and helpers.
Prover handling - if we choose to run the prover internally, there is a need for the module to communicate with the prover module.
Move compiler API - various functions to handle Move compiler communication - the ability to compile source files, generate AST from specified files etc.


### External dependencies

## Command line interface integration

Move mutator can be integrated with any command line interface. To do so, CLI application needs to collect arguments and call the `run_move_mutator` function from the `move_mutator` crate.

Currently, the Move mutator tool is integrated with the `move-cli` and `aptos` command line interfaces. There is introduced a new command: `mutate` which allows to pass the mutator arguments. Check README.md for more details.

## Proving correctness

The Move mutator tool is designed to create mutants only. It does not perform the proving process as it is not the goal of the tool. Output of the Move mutator tool can be consumed by many other tools, not only the Prover. For example, some might want to generate mutants to check 

## Specification verification tool


## Mutation operators

Mutation operators can be divided into two groups. The first group is composed of mutation operators that once replaced, do not change the length of the original program. That operators can potentially be mixed inside on file to achieve more complex mutations. The second group is composed of mutation operators that once replaced, change the length of the original program. That operators cannot be mixed inside one file, so each mutant has only one mutation of that kind. It should be possible to mix many non-changing file length mutation operators with one changing len mutation operator, but the latter needs to be applied as the last one.

The reason to introduce two groups of mutation operators is connected with the way how the Move mutator tool works. It reads the source file(-s) once and then works on the original AST. If any previous mutation changes original file, then it would demand reloading the changed source (as upon change, all current AST locations become outdated), parse the AST and again for possible mutations. It would be very inefficient.

The Move mutator tool implements the following mutation operators:

### Binary operator replacement

This mutation operator replaces binary operators with other binary operators. For example, the `+` operator can be replaced with the `-` operator.

Operators are grouped into the following categories:
- arithmetic operators: `+`, `-`, `*`, `/`, `%`
- bitwise operators: `&`, `|`, `^` 
- shifts: `<<`, `>>`
- comparison operators: `==`, `!=`, `<`, `>`, `<=`, `>=`
- logical operators: `&&`, `||`

Operators are replaced within the same category. For example, the `+` operator can be replaced with the `-` operator, but not with the `<<` operator.

Binary operators are never removed, as it would produce invalid code.

Operator is used to tests the conditions in the specifications and testsuites.

Can be mixed with other non-changing file length mutation operators.

### Unary operator replacement

This mutation operator replaces unary operators with other unary operators. For example, the `!` operator can be replaced with the space. So in fact, it removes the operator, but without changing the file length.

Operator is used to tests the conditions in the specifications and testsuites.

Thanks to the fact, operator is replaced with space instead of just removing, it can be mixed with other non-changing file length mutation operators.

### Type replacement

This mutation operator replaces types with other types. For example, the `u8` type can be replaced with the `u64` type.

Can't be mixed with other mutation operators as it may change the file length.

### Literal replacement

This mutation operator replaces literals with other literals. For example, the `0` literal can be replaced with the `1` literal or other random literal, `true` to `false` etc.

It's possible to choose the type of the literal to be replaced. For example, it's possible to replace only boolean literals.

Operator is used to tests the different conditions in the specifications (like invariants) and testsuites.

Can't be mixed with other mutation operators as it may change the file length.

### Address replacement

This mutation operator replaces addresses with other addresses. For example, the `0x1`/`@std` address can be replaced with the `0x000A` address or other random address.

Can't be mixed with other mutation operators as it may change the file length.

### Return value replacement

This mutation operator replaces return values with other return values. For example, the concrete expressions can be replaced with the concrete literal or other random literal.

Operator is used to tests the conditions in the testsuites and eg. `ensures` statement in specifications.

Can't be mixed with other mutation operators as it may change the file length.

### Break/continue replacement or deletion

This mutation operator replaces break/continue statements with other break/continue statements or deletes them.

Can't be mixed with other mutation operators as it may change the file length.

## Extending the Move mutator tool

The Move mutator tool is designed to be easily extensible. It's possible to add new mutation operators, new mutation categories and so on. The following sections describe how to do it.

### Adding new mutation operator

To add new mutation operator you need to:
1. Add new mutation operator to the `MutationOperator` enum in the `operator.rs` file.
2. Implement mutation logic in the `apply` function in the `operator.rs` file.
3. Update AST traversal code in the `mutate.rs` file - add or modify a place in the AST where the mutation operator should be applied.
4. Add a test for the new mutation operator.

### Adding new mutation category

Sometimes it's useful to group mutation operators into categories. For example, it's useful to group arithmetic operators together. It's possible to do it by adding new mutation category.

Categories exists only for the purpose of grouping mutation operators. They are not used anywhere else. They resides in the `operator.rs` file inside the `apply` function. To add new category simply modify existing operator, adding or excluding new group basing on the already present code (look at the `BinaryOperator`, `ops` vector).



